

Execution Plan: Sourdough App "Bake" Feature
This document outlines the detailed, step-by-step plan to implement the "Bake" functionality. It is designed to integrate with the existing application architecture, reusing components and patterns where possible to ensure simplicity and maintainability.
Guiding Principles
Reuse Existing Patterns: We will follow established patterns for state management (Zustand), API calls (Axios via utils/api.ts), component structure, and routing (react-router-dom).
Backend First: The plan starts with the database and API to provide a solid foundation for all frontend work.
Incremental UI: The UI will be built in logical phases: Bakes List -> Active Bake Screen -> Bake Summary.
Phase 1: Backend Foundation
Step 1.1: Database Schema Modifications
The first step is to update the Prisma schema to support the new features.
File to modify: backend/prisma/schema.prisma
1. Add new enum types for statuses:
enum BakeStatus {
  IN_PROGRESS
  COMPLETED
  CANCELED
}

enum BakeStepStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
}


2. Update the Bake model:
model Bake {
  // ... existing fields
  status    BakeStatus @default(IN_PROGRESS)
  bakeSteps BakeStep[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}


3. Update the BakeStep model:
model BakeStep {
  // ... existing fields
  status          BakeStepStatus @default(PENDING)
  notes           String?
  startTimestamp  DateTime?
  finishTimestamp DateTime?
  // ... relations
}


4. Update the BakeStepParameterValue model:
model BakeStepParameterValue {
  // ... existing fields
  adjustedPlannedValue String?
  actualValue          String?
}


Action: After saving schema.prisma, run npx prisma migrate dev --name bake_feature_schema in the backend directory to generate and apply the new migration.
Step 1.2: Create Backend API Routes
A new set of endpoints is needed to manage bakes.
1. New file: backend/src/routes/bakes.ts
This file should be structured like recipes.ts, importing express, the PrismaClient, and your authMiddleware.
// backend/src/routes/bakes.ts
import express from 'express';
import { PrismaClient } from '@prisma/client';
import { authMiddleware } from '../middleware/authMiddleware';

const router = express.Router();
const prisma = new PrismaClient();

// All routes in this file will be protected
router.use(authMiddleware);

// --- Define Endpoint Logic Below ---

export default router;


2. Add the new router to the main server:
File to modify: backend/src/index.ts
// backend/src/index.ts
// ... other imports
import bakesRoutes from './routes/bakes'; // Add this import

// ... after app.use('/api/recipes', recipesRoutes);
app.use('/api/bakes', bakesRoutes); // Add this line


Step 1.3: Implement Endpoint Logic
Add the logic for each endpoint inside backend/src/routes/bakes.ts.
GET /api/bakes/active: Fetches all bakes for the logged-in user where status = 'IN_PROGRESS'.
POST /api/bakes: Creates a new bake and snapshots the recipe steps. This is the most complex endpoint.
It must find the recipeId from the request body and the userId from req.user.
Create a new Bake record.
Fetch the chosen recipe with all its relations (steps, parameters, ingredients).
Loop through each RecipeStep and create corresponding BakeStep, BakeStepParameterValue, and BakeStepIngredient records, linking them to the new Bake.
Return the newly created bake object with all its new relations.
PUT /api/bakes/:bakeId/cancel: Sets the bake status to CANCELED.
PUT /api/bakes/:bakeId/steps/:stepId/start: Sets step status to IN_PROGRESS and records the current time in startTimestamp.
PUT /api/bakes/:bakeId/steps/:stepId/complete: Sets step status to COMPLETED, records finishTimestamp, and calculates the duration to save in the appropriate actualValue.
PUT /api/bakes/:bakeId/steps/:stepId/skip: Sets step status to SKIPPED.
PUT /api/bakes/:bakeId/steps/:stepId/adjust: Updates the adjustedPlannedValue for a specific parameter.
PUT /api/bakes/:bakeId/steps/:stepId/note: Updates the notes field for a step.
Phase 2: Frontend State & Data Layer
Step 2.1: Create New Frontend Types
Define the shapes of the new data structures for type safety.
New file: frontend/src/types/bake.ts
// frontend/src/types/bake.ts
export type BakeStatus = 'IN_PROGRESS' | 'COMPLETED' | 'CANCELED';
export type BakeStepStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'SKIPPED';

// Define interfaces for Bake, BakeStep, etc., that match the Prisma models.
// Example:
export interface Bake {
  id: string;
  status: BakeStatus;
  bakeSteps: BakeStep[];
  // ... other fields from your schema
}
// ... define other types


Step 2.2: Create the Bake Store
A Zustand store will manage the state of active bakes.
New file: frontend/src/store/useBakeStore.ts
// frontend/src/store/useBakeStore.ts
import { create } from 'zustand';
import { Bake } from '../types/bake';
import api from '../utils/api'; // Reuse your existing api utility

interface BakeState {
  activeBakes: Bake[];
  isLoading: boolean;
  fetchActiveBakes: () => Promise<void>;
  startBake: (recipeId: string) => Promise<Bake | null>;
  // ... define signatures for other actions: cancel, skip, complete, etc.
}

export const useBakeStore = create<BakeState>((set) => ({
  activeBakes: [],
  isLoading: false,
  fetchActiveBakes: async () => { /* ... implementation ... */ },
  startBake: async (recipeId) => { /* ... implementation ... */ },
  // ... implement other actions
}));


Phase 3: Frontend UI - Bakes List & Starting a Bake
Step 3.1: Update Bakes List Page
Modify the existing bakes list page to display active bakes from the new store.
File to modify: frontend/src/pages/bakes/index.tsx
Use the useBakeStore hook to get activeBakes, fetchActiveBakes, and isLoading.
In a useEffect, call fetchActiveBakes() on component mount.
